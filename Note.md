# StudyJWT


## JWT(JSON Web Token)
출처: (https://velopert.com/2389)


## 토큰(Token) 기반 인증

### 소개
- 토큰(Token) 기반 인증은 모던 웹서비스에서 정말 많이 사용되고 있습니다.
- API를 사용하는 웹서비스를 개발한다면, 토큰을 사용하여 유저들의 인증작업을 처리하는 것이 가장 좋은 방법입니다.
- 토큰 기반 인증 시스템을 선택하는데에는 다음과 같은 주요 이유가 있습니다.

- Stateless 서버
    - Stateless 서버를 이해하려면 먼저 Stateful 서버가 무엇인지 알아야합니다.
    - Stateful 서버는 클라이언트에게서 요청을 받을 때마다 클라이언트의 상태를 계속해서 유지하고, 이 정보를 서비스 제공에 이용합니다.
    - Stateful 서버의 예제로는 세션을 유지하는 웹서버가 있습니다.
    - 예를들어 유저가 로그인을 하면, 세션에 로그인이 되었다고 저장을 해두고, 서비스를 제공할 때 그 데이터를 사용합니다.
    - 여기서 이 세션은 서버컴퓨터의 메모리에 담을 때도 있고, 데이터베이스 시스템에 담을 때도 있습니다.
    - Stateless 서버는 이와 반대로 상태를 유지하지 않습니다.
    - 상태정보를 저장하지 않으면, 서버는 클라이언트측에서 들어오는 요청만으로 작업을 처리합니다.
    - 이렇게 상태가 없는 경우 클라이언트와 서버의 연결고리가 없기 때문에 서버의 확장성(Scalability)이 높아집니다.

- 모바일 어플리케이션에 적합하다
    - 만약에 Android / iOS 모바일 어플리케이션을 개발한다면, 안전한 API를 만들기 위해선 쿠키같은 인증시스템은 이상적이지 않습니다(쿠키 컨테이너를 사용해야 합니다).
    - 토큰 기반 인증을 도입한다면, 더욱 간단하게 이 번거로움을 해결할 수 있습니다.

- 인증정보를 다른 어플리케이션으로 전달
    - 대표적인 예제로는 OAuth가 있습니다. 페이스북/구글 같은 소셜 계정들을 이용하여 다른 웹서비스에도 로그인할 수 있게 할 수 있습니다.

- 보안
    - 토큰 기반 인증 시스템을 사용하여 어플리케이션의 보안을 높일 수 있습니다.
    - 하지만 토큰 기반 인증을 사용한다고 해서 해킹의 위험으로부터 완전히 벗어날 수 있는 것은 아닙니다.


왜 토큰을 사용하게 됐을까?
- 토큰 기반 인증 시스템이 어떻게 작동하고, 또 이로 인하여 얻을 수 있는 이득에 대하여 알아보기 전에, 이 토큰 기반 인증 시스템이 어쩌다 나타났는지 알아야 합니다.
- 이를 위해 과거의 인증시스템이 어떤 방식으로 작동 했는지 살펴 볼 필요가 있습니다.

- 서버 기반 인증
    - 기존의 인증 시스템에서는 서버측에서 유저들의 정보를 기억하고 있어야 합니다.
    - 이 세션을 유지하기 위해서 메모리 / 디스크 / 데이터베이스 시스템에 저장합니다.
    - 하지만 서버 기반 인증 시스템은 서버를 확장하기가 어렵다는 단점이 있습니다.

- 서버 기반 인증의 문제점
    - 세션
        - 유저가 인증을 할 때, 서버는 이 기록을 서버에 저장해야 합니다.
        - 이를 세션이라고 부릅니다.
        - 대부분의 경우엔 메모리에 이를 저장하는데, 로그인 중인 유저의 수가 늘어나면 서버의 램에 과부화가 발생합니다.
        - 이를 피하기 위해 세션을 데이터베이스 시스템에 저장하는 방식도 있지만, 이 또한 유저의 수가 많으면 데이터베이스의 성능에 무리를 줄 수 있습니다.

    - 확장성
        - 세션을 사용하면 서버를 확장하는 것이 어려워집니다.
        - 여기서 서버의 확장이란, 단순히 서버의 사양을 업그레이드하는 것이 아니라, 더 많은 트래픽을 감당하기 위하여 여러개의 프로세스를 돌리거나,
        - 여러대의 서버 컴퓨터를 추가하는 것을 의미합니다.
        - 세션을 사용하면서 분산된 시스템을 설계하는 것은 불가능한 것은 아니지만 과정이 매우 복잡합니다.

    - CORS (Cross-Origin Resource Sharing)
        - 웹 어플리케이션에서 세션을 관리할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있습니다.
        - 따라서 쿠키를 여러 도메인에서 관리하는 것은 좀 번거롭습니다.


토큰 기반 시스템의 작동 원리
- 토큰 기반 시스템은 Stateless 합니다.
- 무상태. 즉 상태유지를 하지 않습니다.
- 이 시스템에서는 더 이상 유저의 인증 정보를 서버나 세션에 담아두지 않습니다.
- 이 개념 하나만으로도 위에서 서술한 서버에서 유저의 인증 정보를 서버측에 담아둠으로써 발생하는 많은 문제점들이 해소됩니다.
- 세션이 존재하지 않으니, 유저들이 로그인 되어있는지 안되어있는지 신경도 쓰지 않으면서 서버를 손쉽게 확장할 수 있습니다.
- 토큰 기반 시스템의 구현 방식은 시스템마다 크고 작은 차이가 있지만, 대체로 다음과 같습니다.
    - 1. 유저가 아이디와 비밀번호로 로그인을 합니다.
    - 2. 서버측에서 해당 계정정보를 검증합니다.
    - 3. 계정정보가 정확하다면, 서버측에서 유저에게 signed 토큰을 발급해줍니다.
        - 여기서 signed의 의미는 해당 토큰이 서버에서 정상적으로 발급된 토큰임을 증명하는 signature를 지니고 있다는 것입니다.
    - 4. 클라이언트 측에서 전달받은 토큰을 저장해두고, 서버에 요청을 할 때마다, 해당 토큰을 함께 서버에 전달합니다.
    - 5. 서버는 토큰을 검증하고, 요청에 응답합니다.
- 웹서버에서 토큰을 서버에 전달할 때에는, HTTP 요청의 헤더에 토큰값을 포함시켜서 전달합니다.



토큰의 장점
- 무상태(Stateless)이며 확장성(Scalability)이 있다
    - 토큰은 클라이언트사이드에 저장하기 때문에 완전히 Stateless하며, 서버를 확장하기에 매우 적합한 환경을 제공합니다.
    - 만약에 세션을 서버측에 저장하고 있고, 서버를 여러대를 사용하여 요청을 분산하였다면, 어떤 유저가 로그인 했을 땐, 그 유저는 처음 로그인했었던 그 서버에만 요청을 보내도록 설정을 해야합니다.
    - 하지만, 토큰을 사용한다면, 어떤 서버로 요청이 들어가든 상관이 없습니다.


- 보안성
    - 클라이언트가 서버에 요청을 보낼 때, 더 이상 쿠키를 전달하지 않으므로 쿠키를 사용함으로 인해 발생하는 취약점이 사라집니다.
    - 하지만, 토큰을 사용하는 환경에서도 취약점이 존재할 수 있으므로 언제나 취약점에 대비해야 합니다.


- Extensibility (확장성)
    - 여기서의 확장성은 Scalability와는 또 다른 개념입니다.
    - Scalability는 서버를 확장하는 것을 의미합니다.
    - 반면 Extensibility는 로그인 정보가 사용되는 분야를 확장하는 것을 의미합니다.
    - 토큰을 사용하여 다른 서비스에서도 권한을 공유할 수 있습니다.
    - 예를 들어서, 스타트업 구인구직 웹서비스인 로켓펀치에서는 Facebook, LinkedIn, GitHub, Google 계정으로 로그인을 할 수 있습니다.
    - 토큰 기반 시스템에서는, 토큰에 선택적인 권한만 부여하여 발급을 할 수 있습니다.
    - 예를 들어 로켓펀치에서 페이스북 계정으로 로그인을 했다면, 프로필 정보를 가져오는 권한은 있어도, 포스트를 작성할 수 있는 권한은 없습니다.


- 여러 플랫폼 및 도메인
    - 서버 기반 인증 시스템의 문제점을 다룰 때 CORS(Cross-Origin Resource Sharing)에 대해 언급하였습니다.
    - 어플리케이션과 서비스의 규모가 커지면, 우리는 여러 디바이스를 호환시키고, 더 많은 종류의 서비스를 제공하게 됩니다.
    - 토큰을 사용한다면, 디바이스, 도메인의 종류에 상관 없이 토큰만 유효하다면 요청이 정상적으로 처리됩니다.
    - 서버측에서 어플리케이션의 응답부분에 다음 헤더만 포함시켜주면 됩니다
        - Access-Control-Allow-Origin: *
    - 이런 구조라면, assets 파일들(이미지, css, js, html 파일 등)은 모두 CDN에서 제공을 하도록 하고, 서버측에서는 오직 API만 다루도록 설계할 수도 있습니다.


- 웹 표준 기반
    - 토큰 기반 인증 시스템의 구현체인 JWT는 웹 표준 RFC 7519에 등록이 되어있습니다.
    - 따라서 여러 환경에서 지원이 되며(.NET, Ruby, Java, Node.js, Python, PHP …) 수많은 회사의 인프라스트럭쳐에서 사용되고 있습니다.


JSON Web Token이란?
- 기본정보
    - JSON Web Token(JWT)은 웹표준(RFC 7519)으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인(self-contained) 방식으로 정보를 안전성 있게 전달해줍니다.
- 수많은 프로그래밍 언어에서 지원됩니다
    - JWT는 C, Java, Python, C++, R, C#, PHP, JavaScript, Ruby, Go, Swift 등 대부분의 주류 프로그래밍 언어에서 지원됩니다.
- 자가 수용적(self-contained)입니다.
    - JWT는 필요한 모든 정보를 자체적으로 지니고 있습니다.
    - JWT 시스템에서 발급된 토큰은, 토큰에 대한 기본 정보(header), 전달할 정보(payload, ex: 로그인시스템에서는 유저 정보)와 토큰이 검증됐다는 것을 증명해주는 서명(signature)을 포함하고 있습니다.
- 쉽게 전달될 수 있습니다.
    - JWT는 자가수용적이므로, 두 개체 사이에서 손쉽게 전달될 수 있습니다.
    - 웹서버의 경우 HTTP의 헤더에 넣어서 전달할 수도 있고, URL의 파라미터로 전달할 수도 있습니다.


JWT는 어떤 상황에서 사용될까?
- 다음과 같은 상황에서 JWT가 유용하게 사용될 수 있습니다.
    - 회원 인증: 
        - JWT를 사용하는 가장 흔한 시나리오입니다. 유저가 로그인을 하면, 서버는 유저의 정보에 기반한 토큰을 발급하여 유저에게 전달해줍니다.
        - 그 후, 유저가 서버에 요청을 할 때마다 JWT를 포함하여 전달합니다.
        - 서버가 클라이언트에게서 요청을 받을 때마다, 해당 토큰이 유효하고 인증됐는지 검증을 하고, 유저가 요청한 작업에 권한이 있는지 확인하여 작업을 처리합니다.
        - 서버측에서는 유저의 세션을 유지할 필요가 없습니다. 즉 유저가 로그인되어있는지 안되어있는지 신경 쓸 필요가 없고, 유저가 요청을 했을 때 토큰만 확인하면 되니, 세션 관리가 필요 없어서 서버 자원을 많이 아낄 수 있습니다.
    - 정보 교류:
        - JWT는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법입니다.
        - 정보가 sign이 되어있기 때문에 정보를 보낸이가 바뀌지는 않았는지, 또 정보가 도중에 조작되지는 않았는지 검증할 수 있습니다.


JWT의 생김새
- JWT는 .을 구분자로 3가지의 문자열로 되어있습니다. 구조는 다음과 같습니다.
- aaaaaa.bbbbbb.cccccc
- aaaaaa는 헤더(header), bbbbbb는 내용(payload), cccccc는 서명(signature)입니다.
- 헤더(header)
    - Header는 두 가지의 정보를 지니고 있습니다.
        - typ: 토큰의 타입을 지정합니다. 현재의 경우 JWT입니다.
        - alg: 해싱 알고리즘을 지정합니다. 해싱 알고리즘으로는 보통 HMAC SHA256 혹은 RSA가 사용되며, 이 알고리즘은 토큰을 검증할 때 사용되는 signature 부분에서 사용됩니다.
        - 예시
        - { “typ”: “JWT”, “als”: “HS256” }
        - 위 예제에서는 HMAC SHA256이 해싱 알고리즘으로 사용됩니다.
    - 이 정보를 base64로 인코딩하면 다음과 같습니다.
    - eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
￼


- 정보 (Payload)
    - Payload 부분에는 토큰에 담을 정보가 들어있습니다.
    - 여기에 담는 정보의 한 ‘조각’을 클레임(claim)이라고 부르고, 이는 name / value의 한 쌍으로 이루어져 있습니다.
    - 토큰에는 여러개의 클레임들을 넣을 수 있습니다.
    - 클레임의 종류는 다음과 같이 크게 세 분류로 나뉘어져 있습니다. -> 등록(registered), 공개(public), 비공개(private)
        - 등록된(registered) 클레임
            - 등록된 클레임들은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임들입니다.
            - 등록된 클레임의 사용은 모두 선택적(optional)이며, 이에 포함된 클레임 이름들은 다음과 같습니다.
                - iss: 토큰 발급자(Issuer)
                - sub: 토큰 제목(Subject)
                - aud: 토큰 대상자(Audience)
                - exp: 토큰의 만료시간(expiration), 시간은 NumericDate 형식으로 되어있어야 하며(예: 1489849147370) 언제나 현재 시간보다 이후로 설정되어있어야 합니다.
                - nbf: Not Before를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나가기 전까지는 토큰이 처리되지 않습니다.
                - iat: 토큰이 발급된 시간(issued at), 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단할 수 있습니다.
                - jti: JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.

        - 공개(public) 클레임
            - 공개 클레임들은 충돌이 방지된(collision-resistant) 이름을 가지고 있어야 합니다.
            - 충돌을 방지하기 위해서는, 클레임 이름을 URI 형식으로 짓습니다.
            - { “https://velopert.com/jwt_claims/is_admin”: true }

        - 비공개(private) 클레임
            - 등록된 클레임도 아니고, 공개된 클레임들도 아닙니다.
            - 양 측간에(클라이언트 <-> 서버) 협의하에 사용되는 클레임 이름들입니다.
            - 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용에 유의해야 합니다.
            - { “username”: “velopert”)

    - 예제 Payload
    - { “iss”: “velopert.com”, “exp”: “1485270000000”, “https://velopert.com/jwt_claims/is_admin”: true, “userId”: “11028373727102”, “username”: “velopert” }
    - 위 예제 payload는 2개의 등록된 클레임, 1개의 공개 클레임, 2개의 비공개 클레임으로 이루어져 있습니다.
    - 위 데이터를 base64로 인코딩하면 다음과 같습니다.
    - eyJpc3MiOiJ2ZWxvcGVydC5jb20iLCJleHAiOiIxNDg1MjcwMDAwMDAwIiwiaHR0cHM6Ly92ZWxvcGVydC5jb20vand0X2NsYWltcy9pc19hZG1pbiI6dHJ1ZSwidXNlcklkIjoiMTEwMjgzNzM3MjcxMDIiLCJ1c2VybmFtZSI6InZlbG9wZXJ0In0
￼

- 서명(signature)
    - JSON Web Token의 마지막 부분은 바로 서명(signature)입니다.
    - 이 서명은 헤더의 인코딩값과, 정보의 인코딩값을 합친 후 주어진 비밀키로 해쉬를 하여 생성합니다.
    - 서명 부분을 만드는 수도코드(pseudocode)의 구조는 다음과 같습니다.
    - HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)
    - 이렇게 만든 해쉬를 base64 형태로 나타내면 됩니다(문자열을 인코딩하는게 아닌 hex -> base64 인코딩을 해야합니다)
    - 이 포스트에서 사용된 예제 헤더와 정보를 해싱하는 예시입니다.
    - 헤더와 정보의 인코딩 값 사이에 .을 넣어주고 합칩니다.
    - eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ2ZWxvcGVydC5jb20iLCJleHAiOiIxNDg1MjcwMDAwMDAwIiwiaHR0cHM6Ly92ZWxvcGVydC5jb20vand0X2NsYWltcy9pc19hZG1pbiI6dHJ1ZSwidXNlcklkIjoiMTEwMjgzNzM3MjcxMDIiLCJ1c2VybmFtZSI6InZlbG9wZXJ0In0
    - 이 값의 비밀키의 값을 secret으로 해싱하고 base64로 인코딩하면 다음과 같은 값이 나옵니다
    - WE5fMufM0NDSVGJ8cAolXGkyB5RmYwCto1pQwDIqo2w
    - 지금까지 구한 값들을 .을 중간자로 합쳐주면, 하나의 토큰이 완성됩니다.
    - eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ2ZWxvcGVydC5jb20iLCJleHAiOiIxNDg1MjcwMDAwMDAwIiwiaHR0cHM6Ly92ZWxvcGVydC5jb20vand0X2NsYWltcy9pc19hZG1pbiI6dHJ1ZSwidXNlcklkIjoiMTEwMjgzNzM3MjcxMDIiLCJ1c2VybmFtZSI6InZlbG9wZXJ0In0.WE5fMufM0NDSVGJ8cAolXGkyB5RmYwCto1pQwDIqo2w
￼
